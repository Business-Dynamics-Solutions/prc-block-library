/**
 * WordPress Dependencies
 */
import { store, getContext, getElement } from '@wordpress/interactivity';

const { actions, state } = store('prc-block/table-of-contents', {
	state: {
		get isActive() {
			const context = getContext();
			const { part, chapter, section } = { ...context };

			const itemType = actions.getContextClue(context);
			if ('part' === itemType) {
				return part.is_active;
			}
			if ('chapter' === itemType) {
				return chapter.is_active;
			}
			if ('section' === itemType) {
				return section.is_active;
			}
			return false;
		},
	},
	actions: {
		getInternalChaptersList: () => {
			const { ref } = getElement();
			// check if the first level of the list has list-items with is-top-level class
			// if so, return the first level of the list
			if (
				ref.querySelector(
					'.wp-block-prc-block-table-of-contents__list .is-top-level'
				)
			) {
				return ref.querySelector(
					'.wp-block-prc-block-table-of-contents__list'
				);
			}
			return ref.querySelector(
				'.wp-block-prc-block-table-of-contents__list .wp-block-prc-block-table-of-contents__list'
			);
		},
		initSmoothScrollClickHandler: () => {
			const internalChaptersList = actions.getInternalChaptersList();

			if (!internalChaptersList) {
				return;
			}
			const links = internalChaptersList.querySelectorAll('a');

			if (!links) {
				return;
			}

			links.forEach((link) => {
				link.addEventListener('click', (e) => {
					const href = link.getAttribute('href');
					// If the link is a hash link, we need to smooth scroll to the hash.
					if (0 === href.indexOf('#')) {
						const target = document.getElementById(
							href.replace('#', '')
						);
						if (target) {
							target.scrollIntoView({ behavior: 'smooth' }, true);
							// Add the hash to the end of the URL.
							window.history.pushState(null, null, href);
						}
					}
				});
			});
		},
		onDropdownClick: (event) => {
			event.preventDefault();
			const context = getContext();
			context.isDropdownOpen = !context.isDropdownOpen;
		},
		getContextClue: (context) => {
			// If context.part is defined, but context.chapter and context.section are undefined, then this is a a part. If context.chapter is defined, but context.section is undefined, then this is a chapter. If context.section is defined, then this is a section.
			if (context.part && !context.chapter && !context.section) {
				return 'part';
			} else if (context.chapter && !context.section) {
				return 'chapter';
			} else if (context.section) {
				return 'section';
			}
		},
	},
	callbacks: {
		/**
		 * Remap the foundSections (generated by core/heading blocks in post_content)
		 * to their respective part or chapter in their `sections` property.
		 */
		mapFoundSectionsToChapters: () => {
			const { sectionsFound, postId, partsEnabled } = state;

			// if no sectionsFound, return
			if (!sectionsFound) {
				return;
			}

			// Structure the sectionsFound object into an array of objects
			const mappedSections = Object.entries(sectionsFound).map(
				([key, label]) => ({
					key,
					label,
					url: `#${key}`,
					items: [],
					chapters: [],
					is_active: false,
				})
			);

			const { items } = getContext();

			const unattachedPackagePartIndex = items.findIndex(
				(part) => part.key === `unattachedPackagePart_${postId}`
			);
			if (-1 !== unattachedPackagePartIndex) {
				items[unattachedPackagePartIndex].sections = mappedSections;
			} else if (!partsEnabled) {
				const activeChapterIndex = items.findIndex(
					(chapter) => chapter.is_active === true
				);
				items[activeChapterIndex].sections = mappedSections;
			} else {
				const activePartIndex = items.findIndex((part) => {
					return part.chapters.find(
						(chapter) => chapter.is_active === true
					);
				});
				if (-1 === activePartIndex) {
					return;
				}
				const activeChapterIndex = items[
					activePartIndex
				].chapters.findIndex((chapter) => chapter.is_active === true);

				items[activePartIndex].chapters[activeChapterIndex].sections =
					mappedSections;
			}

			// // Set the local items.
			// getContext().items = items;
		},
		/**
		 * Determine if the current part or chapter has list items.
		 * @return {boolean}
		 */
		hasListItems() {
			const context = getContext();
			const { part, chapter } = { ...context };
			if (undefined === chapter && undefined !== part) {
				return part.sections.length > 0;
			} else if (undefined !== chapter) {
				return chapter.sections.length > 0;
			}
			return false;
		},
		/**
		 * Determine if the current part or chapter is active.
		 * @return {boolean}
		 */
		isActive() {
			const context = getContext();
			const { part, chapter, section } = { ...context };

			const itemType = actions.getContextClue(context);
			if ('part' === itemType) {
				return part.is_active;
			}
			if ('chapter' === itemType) {
				return chapter.is_active;
			}
			if ('section' === itemType) {
				return section.is_active;
			}
			return false;
		},
		/**
		 * When the client is resized, check if the dropdown should be enabled.
		 */
		onResizeToggleDropdown: () => {
			const context = getContext();
			const { autoDropdownEnabled, autoDropdownWidth } = context;
			if (!autoDropdownEnabled) {
				return;
			}
			const { ref } = getElement();
			// get the width of the ref
			const width = ref.offsetWidth;
			// if the width is less than the autoDropdownWidth and autoDropdownEnabled is true
			// set isDropdown to true
			if (width < autoDropdownWidth && autoDropdownEnabled) {
				context.isDropdown = true;
			} else {
				context.isDropdown = false;
			}
		},
		/**
		 * When a click event occurs inside the window,
		 * but outside the dropdown target, close the dropdown.
		 * @param {*} event
		 */
		onWindowClickCloseDropdown: (event) => {
			const context = getContext();
			const { ref } = getElement();
			if (!ref.contains(event.target) && context.isDropdown) {
				context.isDropdownOpen = false;
			}
		},
		/**
		 * Scroll smoothly when clicking on a # link
		 * @param {*} event
		 */
		scrollSmoothly: (event) => {
			const context = getContext();
			const { section } = context;
			const { key } = section;
			event.preventDefault();
			const target = document.getElementById(key);

			if (target) {
				target.scrollIntoView({ behavior: 'smooth' }, true);
				window.history.pushState(null, null, `#${key}`);
			}
		},
		// Section Scroll
		/**
		 * Initialize the watch for section scroll if this specific block has it enabled.
		 */
		initWatchForSectionScroll: () => {
			const context = getContext();
			const { highlightCurrentSection } = context;
			if (true === highlightCurrentSection) {
				state.enableWatchForSectionScroll = true;
			}
		},
		watchForCurrentSection: () => {
			const context = getContext();
			if (
				!state.enableWatchForSectionScroll &&
				!context.highlightCurrentSection
			) {
				return;
			}
			const { key } = context.section;
			const { currentSection } = state;
			context.section.is_active = key === currentSection;
		},
		/**
		 * This runs exclusivley on core/heading blocks.
		 * This function watches the scroll position of the page and determines if the current
		 * heading is in view. If it is, it sets the currentSection to the id of the heading.
		 */
		watchForSectionScroll: () => {
			if (!state.enableWatchForSectionScroll) {
				return;
			}

			const sections = state.sectionsFound;
			const sectionKeys = Object.keys(sections);
			const threshold = 50;
			const scrollPosition = window.scrollY;

			let currentSectionKey = null;

			for (let i = 0; i < sectionKeys.length; i++) {
				const key = sectionKeys[i];
				const sectionElement = document.getElementById(key);
				if (!sectionElement) continue;
				const sectionTop = sectionElement.offsetTop;
				if (sectionTop - scrollPosition <= threshold) {
					currentSectionKey = key;
				} else {
					// As soon as we find a section below the threshold, stop
					break;
				}
			}

			state.currentSection = currentSectionKey;
		},
	},
});
